package com.care.notification.infrastructure.persistence.entity;

import com.care.notification.application.dto.NotificationRequest;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * JPA Entity for persisting notification records
 *
 * Stores all notification attempts including:
 * - Request metadata
 * - Delivery status and results
 * - Retry information
 * - User communication history
 */
@Entity
@Table(name = "notifications", indexes = {
    @Index(name = "idx_beneficiary_id", columnList = "beneficiary_id"),
    @Index(name = "idx_status", columnList = "status"),
    @Index(name = "idx_channel", columnList = "channel"),
    @Index(name = "idx_created_at", columnList = "created_at"),
    @Index(name = "idx_notification_type", columnList = "notification_type"),
    @Index(name = "idx_idempotency_key", columnList = "idempotency_key", unique = true)
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NotificationEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id")
    private UUID id;

    /**
     * Idempotency key to prevent duplicate notifications
     * Should be generated by client or based on appointment + user + type
     */
    @Column(name = "idempotency_key", nullable = false, unique = true)
    private String idempotencyKey;

    @Column(name = "beneficiary_id", nullable = false)
    private UUID beneficiaryId;

    @Column(name = "mobile_number", length = 20)
    private String mobileNumber;

    @Column(name = "email", length = 255)
    private String email;

    @Column(name = "device_id", length = 500)
    private String deviceId;

    @Column(name = "has_installed_mobile_app")
    private boolean hasInstalledMobileApp;

    @Column(name = "preferred_channel", length = 20)
    private String preferredChannel;

    /**
     * Notification type enum: APPOINTMENT_CREATED, APPOINTMENT_REMINDER, etc.
     */
    @Column(name = "notification_type", nullable = false, length = 50)
    private String notificationType;

    /**
     * Actual channel used for successful delivery
     */
    @Column(name = "channel", nullable = false, length = 20)
    private String channel;

    /**
     * Delivery status: PENDING, SENT, FAILED, BOUNCED, RETRYING
     */
    @Column(name = "status", nullable = false, length = 20)
    @Enumerated(EnumType.STRING)
    private NotificationStatus status;

    /**
     * Whether notification was successfully delivered
     */
    @Column(name = "is_success")
    private boolean isSuccess;

    /**
     * Error message if delivery failed
     */
    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;

    /**
     * Number of delivery attempts
     */
    @Column(name = "retry_count")
    @Builder.Default
    private int retryCount = 0;

    /**
     * Maximum number of retries allowed
     */
    @Column(name = "max_retries")
    @Builder.Default
    private int maxRetries = 3;

    /**
     * When the next retry should occur
     */
    @Column(name = "next_retry_at")
    private LocalDateTime nextRetryAt;

    /**
     * External provider's message ID (e.g., SendGrid message ID, Twilio SID)
     */
    @Column(name = "provider_message_id", length = 500)
    private String providerMessageId;

    /**
     * External provider webhook response for async delivery feedback
     */
    @Column(name = "provider_webhook_data", columnDefinition = "TEXT")
    private String providerWebhookData;

    /**
     * Appointment ID associated with this notification
     */
    @Column(name = "appointment_id")
    private UUID appointmentId;

    /**
     * Appointment code for reference
     */
    @Column(name = "appointment_code", length = 50)
    private String appointmentCode;

    /**
     * Additional metadata stored as JSON
     */
    @Column(name = "metadata", columnDefinition = "TEXT")
    private String metadata;

    /**
     * Template ID used for this notification (for future template system)
     */
    @Column(name = "template_id")
    private UUID templateId;

    /**
     * Timestamp when notification was sent
     */
    @Column(name = "sent_at")
    private LocalDateTime sentAt;

    /**
     * Timestamp when notification was delivered (webhook confirmation)
     */
    @Column(name = "delivered_at")
    private LocalDateTime deliveredAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    /**
     * Flag for soft delete
     */
    @Column(name = "is_deleted")
    @Builder.Default
    private boolean isDeleted = false;

    /**
     * Enum for notification delivery status
     */
    public enum NotificationStatus {
        PENDING,      // Queued but not yet sent
        SENT,         // Delivered to provider/user
        FAILED,       // Delivery failed, won't retry
        BOUNCED,      // Email bounced or invalid
        RETRYING,     // Failed but will retry
        DELIVERED,    // Confirmed delivery via webhook
        OPENED,       // User opened email (future feature)
        CLICKED       // User clicked link in email (future feature)
    }

    /**
     * Create a notification entity from request
     */
    public static NotificationEntity fromRequest(NotificationRequest request, String idempotencyKey) {
        return NotificationEntity.builder()
            .idempotencyKey(idempotencyKey)
            .beneficiaryId(request.getBeneficiaryId())
            .mobileNumber(request.getMobileNumber())
            .email(request.getEmail())
            .deviceId(request.getDeviceId())
            .hasInstalledMobileApp(request.isHasInstalledMobileApp())
            .preferredChannel(request.getPreferredChannel())
            .notificationType(request.getNotificationType().name())
            .status(NotificationStatus.PENDING)
            .appointmentId(request.getAppointmentQR() != null ?
                request.getAppointmentQR().getAppointmentId() : null)
            .appointmentCode(request.getAppointmentQR() != null ?
                request.getAppointmentQR().getAppointmentCode() : null)
            .build();
    }
}
